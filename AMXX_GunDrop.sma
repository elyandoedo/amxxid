/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <fakemeta_util>
#include <hamsandwich>
#include <cstrike>
#include <fun>



new ironfan_dropeff
new index_dropeffect, index_dropeffect2, laser_line2

public plugin_init()
{
	register_forward(FM_SetModel, "DropWeapon_Effect", 0)
	register_forward(FM_Think, "iDrop_Think")
	register_forward(FM_Touch, "WeaponDrop_EffecTouch", 1)	
	ironfan_dropeff = register_cvar("gun_drop_ef", "1") 
}
public plugin_precache()
{
	index_dropeffect = precache_model("sprites/drop_effring.spr")
	index_dropeffect2 = precache_model("models/ef_gundrop.mdl")
	laser_line2 = precache_model("sprites/drop_effbeam.spr")
}

//丟棄武器鉤子
public DropWeapon_Effect(ent, model[])
{
	if(!pev_valid(ent)) return HAM_IGNORED
	new class[33]
	pev(ent, pev_classname, class, 32)
	if(!equal(class, "weaponbox")) return HAM_IGNORED
	if(!get_pcvar_num(ironfan_dropeff)) return HAM_IGNORED
	
	create_dropeffect(ent)

	return HAM_IGNORED
}
//創建地上的武器效果
public create_dropeffect(ent2)
{
	new OnceNoise[33]
	pev(ent2, pev_noise1, OnceNoise, 32)
	if(equal(OnceNoise, "DropWeapon_Effect")) return
	
	static ent
	ent = fm_create_entity("env_sprite")
	
	set_pev(ent, pev_classname, "drop_effect")
	set_pev(ent, pev_modelindex, index_dropeffect2)
	set_pev(ent, pev_aiment, ent2)
	set_pev(ent, pev_solid, 0)
	
	set_pev(ent, pev_movetype, MOVETYPE_FOLLOW)
	set_pev(ent, pev_iuser2, ent2)
	set_pev(ent2, pev_noise1, "DropWeapon_Effect")
	set_pev(ent, pev_scale, 0.1)
	set_pev(ent, pev_nextthink, get_gametime() + 0.15)
	set_pev(ent, pev_fuser3, get_gametime() + 999.0)
	set_pev(ent, pev_iuser3, 1)
}

public WeaponDrop_EffecTouch(ent, id)
{
	
	if(!pev_valid(ent)) return HAM_IGNORED
	new class[33]
	pev(ent, pev_classname, class, 32)
	if(!equal(class, "drop_effect")) return HAM_IGNORED
	
	if(is_user_alive(id)) 
	client_print(id, print_center, "#CSX_GUN_DROP_EFFECT")
}


public iDrop_Think(ent)
{
	
	if(!pev_valid(ent)) return
	new class[33]
	pev(ent, pev_classname, class, 32)
	if(!equal(class, "drop_effect")) return
	
	new Float:nOrigin[3], Float:nDowndest[3]
	pev(ent, pev_origin, nOrigin)
	nDowndest[0] = nOrigin[0]
	nDowndest[1] = nOrigin[1]
	nDowndest[2] = nOrigin[2] - 7.5
	
	static tr
	engfunc(EngFunc_TraceMonsterHull, ent, nOrigin, nDowndest, 1, ent, tr)
	
	static Float:fraction
	get_tr2(tr, TR_flFraction, fraction)
	
	free_tr2(tr)

	if(fraction != 1.0 && pev(ent, pev_iuser3))
		set_pev(ent, pev_iuser3, 0)
	
	new ownerweapon = pev(ent, pev_iuser2)
	if(!pev_valid(ownerweapon) || !ownerweapon)
	{
		fm_remove_entity(ent)
		return
	}

	if(!pev(ent, pev_iuser3) && pev(ent, pev_modelindex) == index_dropeffect2)
	{
		set_pev(ent, pev_rendermode, 8)
		set_pev(ent, pev_renderamt, 158.0 + 30.0)
		
		new Float:iOrigin[3]
		pev(ownerweapon, pev_origin, iOrigin)
		iOrigin[2] +=1.25
		
		static ent2
		ent2 = fm_create_entity("env_sprite")
	
		set_pev(ent2, pev_origin, iOrigin)
		set_pev(ent2, pev_classname, "drop_effect")
		set_pev(ent2, pev_modelindex, index_dropeffect)
		set_pev(ent2, pev_movetype, 5)
		set_pev(ent2, pev_solid, 1)
		set_pev(ent2, pev_iuser2, pev(ent, pev_iuser2))
		set_pev(ent2, pev_noise1, "DropWeapon_Effect")
		set_pev(ent2, pev_scale, 0.07)
		set_pev(ent2, pev_rendermode, 5)
		set_pev(ent2, pev_rendercolor, {255.0, 255.0, 255.0})
		set_pev(ent2, pev_renderamt, 158.0)
		set_pev(ent2, pev_iuser3, 1)
		set_pev(ent2, pev_nextthink, get_gametime() )
		set_pev(ent2, pev_fuser3, get_gametime() )
		set_pev(ent2, pev_fuser4, 70.0)
		
		new Mins[3]
		Mins[0] = -36.0
		Mins[1] = -36.0
		Mins[2] = -6.0
		
		new Float:Maxs[3]
		Maxs[0] = floatabs(Mins[0])
		Maxs[1] = floatabs(Mins[1])
		Maxs[2] = floatabs(Mins[2])
		engfunc(EngFunc_SetSize, ent2, Mins, Maxs)
		
		new Float:ang[3]
		pev(ent, pev_angles, ang)
		ang[0] = 90.0
		set_pev(ent2, pev_angles, ang)
		
		fm_remove_entity(ent)
		return
	}
	
	new Float:ang[3]
	pev(ent, pev_angles, ang)
		
	ang[1] += 5.0
	ang[0] = 90.0
		
	if(ang[1] > 360.0) ang[1] = 0.0
	set_pev(ent, pev_angles, ang)
	
	new Float:fuser3
	pev(ent, pev_fuser3, fuser3)
	
	new Float:fOrigin[3], Float:dest[3]
	pev(ownerweapon, pev_origin, fOrigin)
	
	if(pev(ent, pev_modelindex) == index_dropeffect)
	{
		//如果沒有顯示 則改為漸漸顯示
		if(pev(ent, pev_iuser3))
		{
			new Float:iAdd = 12.0//" //每次增加多少透明度
			new Float:CurrentAmt
			pev(ent, pev_renderamt, CurrentAmt)
			if(CurrentAmt + iAdd >= 255.0)
			{
				CurrentAmt = 255.0
				set_pev(ent, pev_iuser3, 0) //不需要增加了
			}
			else CurrentAmt += iAdd
			
			set_pev(ent, pev_renderamt, CurrentAmt)
		}
		
		fOrigin[2] += 1.5
		set_pev(ent, pev_origin, fOrigin)
		
		new Float:iAdder = 3.0
		new Float:CurrentHigh
		pev(ent, pev_fuser4, CurrentHigh)
		if(CurrentHigh + iAdder > 80.0)
		{
			CurrentHigh = 80.0
			set_pev(ent, pev_fuser4, 80.0)
		}
		else
		{
			CurrentHigh += iAdder
			set_pev(ent, pev_fuser4, CurrentHigh + iAdder)
		}
		
		if(fuser3 <= get_gametime())
		{
			dest[0] = fOrigin[0]
			dest[1] = fOrigin[1]
			dest[2] = fOrigin[2] + CurrentHigh
			Meessage_BeamSpr(dest, fOrigin, 2, 250, 255, 255, 255, 4)
			
			set_pev(ent, pev_fuser3, get_gametime() + 0.02)
		}
	}
	set_pev(ent, pev_nextthink, get_gametime() + 0.08)
}

stock Meessage_BeamSpr(Float:start[3], Float:end[3], xd, light, r, g, b, wh)
{
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_BEAMPOINTS)
	write_coord(floatround(start[0]) )
	write_coord(floatround(start[1]) )
	write_coord(floatround(start[2]) )
	write_coord(floatround(end[0]) )
	write_coord(floatround(end[1]) )
	write_coord(floatround(end[2]) )
	write_short(laser_line2)
	
	write_byte(0) 
	write_byte(1)
	write_byte(xd) 
	write_byte(wh) 
	write_byte(0) 
	write_byte(r)
	write_byte(g)
	write_byte(b)
	write_byte(light)
	write_byte(0)
	message_end()
}
