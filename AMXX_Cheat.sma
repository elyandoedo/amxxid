/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta>
#include <fakemeta_util>
#include <hamsandwich>
#include <cstrike>
#define PLUGIN "New Plug-In"
#define VERSION "1.0"
#define AUTHOR "author"

new cvar[33][3], g_hamczbots,g_cheat[33]
new const WEAPONSNAME[][] = { "", "weapon_p228", "", "weapon_scout", "weapon_hegrenade", "weapon_xm1014", "weapon_c4", "weapon_mac10",
			"weapon_aug", "weapon_smokegrenade", "weapon_elite", "weapon_fiveseven", "weapon_ump45", "weapon_sg550",
			"weapon_galil", "weapon_famas", "weapon_usp", "weapon_glock18", "weapon_awp", "weapon_mp5navy", "weapon_m249",
			"weapon_m3", "weapon_m4a1", "weapon_tmp", "weapon_g3sg1", "weapon_flashbang", "weapon_deagle", "weapon_sg552",
			"weapon_ak47", "weapon_knife", "weapon_p90"
}
new g_current_wpn[33]
const m_pPlayer			= 41
const m_flNextPrimaryAttack	= 46
const m_flNextSecondaryAttack	= 47
const m_flTimeWeaponIdle	= 48
const m_flNextAttack		= 83
new Float:cl_pushangle[33][3]
public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	register_forward(FM_CmdStart, "fw_CmdStart" )
	RegisterHam(Ham_Spawn, "player", "fw_PlayerSpawn_Post", 1)
	RegisterHam(Ham_TraceAttack, "player", "fw_traceattack")
	RegisterHam(Ham_TakeDamage, "player", "fw_TakeDamage_c")
	register_event("CurWeapon","event_CurWeapon_c","be","1=1")
	
	for(new i=1; i<=CSW_P90; i++)
	{
		if (strlen(WEAPONSNAME[i]))
		{
			RegisterHam(Ham_Weapon_PrimaryAttack, WEAPONSNAME[i], "fw_Weapon_PrimaryAttack_Post_c", 1)	
			RegisterHam(Ham_Weapon_Reload, WEAPONSNAME[i], "fw_Weapon_Reload_Post_c", 1)
		}
	}
	register_clcmd("csr_cheat2","test")
	
}
public fw_CmdStart(id, uc_handle, seed)
{
	if(!is_user_alive(id))
		return
	if(cvar[id][0])
	{
		static Body, Target
		get_user_aiming(id, Target, Body, floatround(999999.0))
		if(is_user_alive(Target)) 
		{
			do_attack(id, Target, fm_get_user_weapon_entity(id, get_user_weapon(id)), float(240))
		} 
	}
}
public fw_PlayerSpawn_Post(id)
{
	// Not alive or didn't join a team yet
	if (!is_user_alive(id))
		return;
	if(cvar[id][1])
	{
		for(new i = 0; i < get_maxplayers(); i++)
		{
			if(!is_user_alive(i))
				continue
			if(id == i)
				continue
			do_attack(id, i, fm_get_user_weapon_entity(id, get_user_weapon(id)), float(240))
		}	
	}
	
}
public client_putinserver(id) {
	if (is_user_bot(id) && !g_hamczbots && get_cvar_pointer("bot_quota"))
	{
		//register zbot
		set_task(0.1, "register_ham_czbots", id)
	}
	cvar[id][0] = 0
	cvar[id][1] = 0
	cvar[id][2] = 0
	g_cheat[id] = false
	
}
public test(id)
{ 
	new menu = menu_create("[Cheat]", "cheat_menu2")  
	{
		if(!cvar[id][0])
		{
			menu_additem( menu, "Auto Kill [OFF]", "1" )
			
		}
		else 
		{
			menu_additem( menu, "Auto Kill [ON]", "1" )
		}
		
		if(!cvar[id][1])
		{
			menu_additem( menu, "Auto Kill 2 [OFF]", "2" )
		}
		else 
		{
			menu_additem( menu, "Auto Kill 2 [ON]", "2" )
		}
		
		if(!cvar[id][2]) 
		{
			menu_additem( menu, "Auto Headshot [OFF]", "3" )
		}
		else 
		{
			menu_additem( menu, "Auto Headshot [ON]", "3" )
		}
		
		if(!g_cheat[id]) 
		{
			menu_additem( menu, "Wpn Cheat [OFF]", "4" )
		}
		else
		{
			menu_additem( menu, "Wpn Cheat [ON]", "4" )
		}
		
		
	}
	
	menu_additem( menu, "Exit", "MENU_EXIT" )
	menu_setprop(menu, MPROP_PERPAGE, 0)
	menu_display(id, menu, 0)
	return 
}

public cheat_menu2(id, menu, item)
{
    if(item == MENU_EXIT)
    {
        menu_destroy(menu)
        return PLUGIN_HANDLED
    }
    new data[6], iName[64]
    new access, callback

    menu_item_getinfo(menu, item, access, data, 6, iName, 63, callback)
   
    new key = str_to_num(data)  

    if(key == 1)
    {
	
	if(!cvar[id][0]) cvar[id][0] = 1
	else cvar[id][0] = 0
    }
 
    if(key == 2)
    {
        
        if(!cvar[id][1])
        {
	       cvar[id][1] = 1
	       for(new i = 0; i < get_maxplayers(); i++)
		{
			if(!is_user_alive(i))
				continue
			if(id == i)
				continue
			do_attack(id, i, fm_get_user_weapon_entity(id, get_user_weapon(id)), float(240))
		}
        }
        else 
        {
	       cvar[id][1] = 0
        }
   
    }
    if(key == 3)
    {
    	
	if(!cvar[id][2]) cvar[id][2] = 1
	else cvar[id][2] = 0
    }
   
    if(key == 8)
    {
    	
	if(!g_cheat[id]) g_cheat[id] = true
	else g_cheat[id] = false
    }
    
    menu_destroy(menu)
    return PLUGIN_HANDLED
}
public event_CurWeapon_c(id)
{
	if (!is_user_alive(id) || is_user_bot(id)) return;
	
	new wpnid, wpnclip, wpnammo
	wpnid = get_user_weapon(id, wpnclip , wpnammo)
	if(!g_cheat[id]) 
		return 
	// update current wpn
	if (g_current_wpn[id] != wpnid)
	{
		g_current_wpn[id] = wpnid
		// set deploy time
		new Float:tdeploy = 0.01
		if (wpnclip && tdeploy) set_player_nextattack(id, tdeploy)
	}
	
}
public fw_TakeDamage_c(victim, inflictor, attacker, Float:damage, damage_type)
{
	if(is_user_bot(attacker)) 
		return HAM_IGNORED
	if(!g_cheat[attacker]) 
		return HAM_IGNORED;
	if (victim == attacker)
		return HAM_IGNORED;

	// Fix bug player not connect
	if (!pev_valid(victim) || !is_user_connected(attacker))
		return HAM_IGNORED;
	
	// Take damage
	new Float:xdamage = 100.0
	if (xdamage>0.0)
	{
		damage *= xdamage
		SetHamParamFloat(4, damage)
	}
	
	return HAM_IGNORED
}

public fw_Weapon_PrimaryAttack_Post_c(ent)
{
	new id = pev(ent,pev_owner)
	if(is_user_bot(id)) 
		return 
	if(!g_cheat[id]) 
		return
	// set speed of weapon
	new Float:speed = 0.1

	new Float:delay = get_pdata_float(ent, m_flNextPrimaryAttack, 4)*speed
	if (delay>0.0) set_pdata_float(ent, m_flNextPrimaryAttack, delay, 4)
	
	// set recoil of weapon
	new Float:recoil = 0.1
	if (recoil>0.0)
	{
		// recoil when sight
		
		new Float:push[3]
		pev(id, pev_punchangle, push)
		xs_vec_sub(push, cl_pushangle[id], push)
		xs_vec_mul_scalar(push, recoil, push)
		xs_vec_add(push, cl_pushangle[id], push)
		set_pev(id, pev_punchangle, push)
	}
}
public fw_Weapon_Reload_Post_c(ent)
{
	new id = pev(ent,pev_owner)
	if(is_user_bot(id)) 
		return 
	if(!g_cheat[id]) 
		return
	// set time reload
	new Float:time_reload = 0.1

	if (time_reload) set_player_nextattack(id, time_reload)
}
stock set_player_nextattack(id, Float:nexttime)
{
	set_pdata_float(id, m_flNextAttack, nexttime, 4)
}

public register_ham_czbots(id) {
	if (g_hamczbots || !is_user_connected(id)) return
	
	RegisterHamFromEntity(Ham_Spawn, id, "fw_PlayerSpawn_Post", 1)
	RegisterHamFromEntity(Ham_TraceAttack, id, "fw_traceattack")
	// HAM FORWARD FOR BOTS
	g_hamczbots = true
	
	if (is_user_alive(id)) fw_PlayerSpawn_Post(id)
}

public fw_traceattack(victim, attacker, Float:damage, direction[3], traceresult, dmgbits)
{
	if(victim != attacker && is_user_connected(attacker) && cvar[attacker][2])
	{
		set_tr2(traceresult, TR_iHitgroup, HIT_HEAD)
	}
	
	
}
do_attack(Attacker, Victim, Inflictor, Float:fDamage)
{
	fake_player_trace_attack(Attacker, Victim, fDamage)
	fake_take_damage(Attacker, Victim, fDamage, Inflictor)
	
}

fake_player_trace_attack(iAttacker, iVictim, &Float:fDamage)
{
	// get fDirection
	new Float:fAngles[3], Float:fDirection[3]
	pev(iAttacker, pev_angles, fAngles)
	angle_vector(fAngles, ANGLEVECTOR_FORWARD, fDirection)
	
	// get fStart
	new Float:fStart[3], Float:fViewOfs[3]
	pev(iAttacker, pev_origin, fStart)
	pev(iAttacker, pev_view_ofs, fViewOfs)
	xs_vec_add(fViewOfs, fStart, fStart)
	
	// get aimOrigin
	new iAimOrigin[3], Float:fAimOrigin[3]
	get_user_origin(iAttacker, iAimOrigin, 3)
	IVecFVec(iAimOrigin, fAimOrigin)
	
	// TraceLine from fStart to AimOrigin
	new ptr = create_tr2() 
	engfunc(EngFunc_TraceLine, fStart, fAimOrigin, DONT_IGNORE_MONSTERS, iAttacker, ptr)
	new pHit = get_tr2(ptr, TR_pHit)
	new iHitgroup = get_tr2(ptr, TR_iHitgroup)
	new Float:fEndPos[3]
	get_tr2(ptr, TR_vecEndPos, fEndPos)

	// get target & body at aiming
	new iTarget, iBody
	get_user_aiming(iAttacker, iTarget, iBody)
	
	// if aiming find target is iVictim then update iHitgroup
	if (iTarget == iVictim)
	{
		iHitgroup = iBody
	}
	
	// if ptr find target not is iVictim
	else if (pHit != iVictim)
	{
		// get AimOrigin in iVictim
		new Float:fVicOrigin[3], Float:fVicViewOfs[3], Float:fAimInVictim[3]
		pev(iVictim, pev_origin, fVicOrigin)
		pev(iVictim, pev_view_ofs, fVicViewOfs) 
		xs_vec_add(fVicViewOfs, fVicOrigin, fAimInVictim)
		fAimInVictim[2] = fStart[2]
		fAimInVictim[2] += get_distance_f(fStart, fAimInVictim) * floattan( fAngles[0] * 2.0, degrees )
		
		// check aim in size of iVictim
		new iAngleToVictim = get_angle_to_target(iAttacker, fVicOrigin)
		iAngleToVictim = abs(iAngleToVictim)
		new Float:fDis = 2.0 * get_distance_f(fStart, fAimInVictim) * floatsin( float(iAngleToVictim) * 0.5, degrees )
		new Float:fVicSize[3]
		pev(iVictim, pev_size , fVicSize)
		if ( fDis <= fVicSize[0] * 0.5 )
		{
			// TraceLine from fStart to aimOrigin in iVictim
			new ptr2 = create_tr2() 
			engfunc(EngFunc_TraceLine, fStart, fAimInVictim, DONT_IGNORE_MONSTERS, iAttacker, ptr2)
			new pHit2 = get_tr2(ptr2, TR_pHit)
			new iHitgroup2 = get_tr2(ptr2, TR_iHitgroup)
			
			// if ptr2 find target is iVictim
			if ( pHit2 == iVictim && (iHitgroup2 != HIT_HEAD || fDis <= fVicSize[0] * 0.25) )
			{
				pHit = iVictim
				iHitgroup = iHitgroup2
				get_tr2(ptr2, TR_vecEndPos, fEndPos)
			}
			
			free_tr2(ptr2)
		}
		
		// if pHit still not is iVictim then set default HitGroup
		if (pHit != iVictim)
		{
			// set default iHitgroup
			iHitgroup = HIT_GENERIC
			
			new ptr3 = create_tr2() 
			engfunc(EngFunc_TraceLine, fStart, fVicOrigin, DONT_IGNORE_MONSTERS, iAttacker, ptr3)
			get_tr2(ptr3, TR_vecEndPos, fEndPos)
			
			// free ptr3
			free_tr2(ptr3)
		}
	}
	
	// set new Hit & Hitgroup & EndPos
	set_tr2(ptr, TR_pHit, iVictim)
	set_tr2(ptr, TR_iHitgroup, iHitgroup)
	set_tr2(ptr, TR_vecEndPos, fEndPos)
	
	// hitgroup multi fDamage
	new Float:fMultifDamage 
	switch(iHitgroup)
	{
		case HIT_HEAD: fMultifDamage  = 2.0
		case HIT_STOMACH: fMultifDamage  = 1.10
		case HIT_LEFTLEG: fMultifDamage  = 0.75
		case HIT_RIGHTLEG: fMultifDamage  = 0.75
		default: fMultifDamage  = 1.0
	}
	
	fDamage *= 2.0 
	
	// ExecuteHam
	fake_trake_attack(iAttacker, iVictim, fDamage, fDirection, ptr)
	
	// free ptr
	free_tr2(ptr)
}

stock fake_trake_attack(iAttacker, iVictim, Float:fDamage, Float:fDirection[3], iTraceHandle, iDamageBit = (DMG_NEVERGIB | DMG_BULLET))
{
	ExecuteHamB(Ham_TraceAttack, iVictim, iAttacker, fDamage, fDirection, iTraceHandle, iDamageBit)
}

stock fake_take_damage(iAttacker, iVictim, Float:fDamage, iInflictor = 0, iDamageBit = (DMG_NEVERGIB | DMG_BULLET))
{
	iInflictor = (!iInflictor) ? iAttacker : iInflictor
	ExecuteHamB(Ham_TakeDamage, iVictim, iInflictor, iAttacker, fDamage, iDamageBit)
}
stock get_angle_to_target(id, const Float:fTarget[3], Float:TargetSize = 0.0)
{
	new Float:fOrigin[3], iAimOrigin[3], Float:fAimOrigin[3], Float:fV1[3]
	pev(id, pev_origin, fOrigin)
	get_user_origin(id, iAimOrigin, 3) // end position from eyes
	IVecFVec(iAimOrigin, fAimOrigin)
	xs_vec_sub(fAimOrigin, fOrigin, fV1)
	
	new Float:fV2[3]
	xs_vec_sub(fTarget, fOrigin, fV2)
	
	new iResult = get_angle_between_vectors(fV1, fV2)
	
	if (TargetSize > 0.0)
	{
		new Float:fTan = TargetSize / get_distance_f(fOrigin, fTarget)
		new fAngleToTargetSize = floatround( floatatan(fTan, degrees) )
		iResult -= (iResult > 0) ? fAngleToTargetSize : -fAngleToTargetSize
	}
	
	return iResult
}

stock get_angle_between_vectors(const Float:fV1[3], const Float:fV2[3])
{
	new Float:fA1[3], Float:fA2[3]
	engfunc(EngFunc_VecToAngles, fV1, fA1)
	engfunc(EngFunc_VecToAngles, fV2, fA2)
	
	new iResult = floatround(fA1[1] - fA2[1])
	iResult = iResult % 360
	iResult = (iResult > 180) ? (iResult - 360) : iResult
	
	return iResult
}
