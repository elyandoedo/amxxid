/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <fakemeta_util>
#include <hamsandwich>
#include <fun>
#include <engine>
#include <cstrike>

#pragma compress 1
#define PLUGIN "Kamen Rider"
#define VERSION "1.0"
#define AUTHOR "EDo"
#define v_kick_m "models/rider/v_foot_m.mdl"
new g_fly[33], g_action[33], g_wait[33], kick_cvar[8], g_OldModel[33][64], g_spr_exp, g_spr_hensin, g_rider[33], g_OldModelChara[33][64], g_model_index
new g_dir_model[64] = "models/player/%s/%s.mdl"
const OFFSET_LINUX = 5
const OFFSET_MODELINDEX = 491
public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	kick_cvar[0] = register_cvar("rider_kick_power1","950.0")
	kick_cvar[1] = register_cvar("rider_kick_power2","1800.0")
	kick_cvar[2] = register_cvar("rider_kick_radius","500.0")
	kick_cvar[3] = register_cvar("rider_kick_damage","2000.0")
	kick_cvar[4] = register_cvar("rider_kick_knockback","2500.0")
	kick_cvar[5] = register_cvar("rider_kick_time","2.0")
	kick_cvar[6] = register_cvar("rider_kick_auto","0")
	kick_cvar[7] = register_cvar("rider_time","10.0")
	register_forward(FM_ClientCommand , "client_command")
	register_forward(FM_CmdStart, "fw_CmdStart")
	register_concmd("rider_henshin","berubah_Rx")
}
public client_command(id)
{
	new Command[32]
	read_argv(0, Command, charsmax(Command))
	
	if(equali(Command,"weapon_",7) && g_action[id] || equali(Command,"lastinv") && g_action[id])
		return PLUGIN_HANDLED

		
	return PLUGIN_CONTINUE;
}
public plugin_precache()
{
	g_spr_exp = engfunc(EngFunc_PrecacheModel,"sprites/rider/groundexp1.spr")
	g_spr_hensin = engfunc(EngFunc_PrecacheModel,"sprites/rider/ef_teleportzombie.spr")
	engfunc(EngFunc_PrecacheModel, v_kick_m)
	engfunc(EngFunc_PrecacheSound, "rider/teleport_skill1.wav")
	new modelurl[64]
	format(modelurl, charsmax(modelurl), g_dir_model, "rx", "rx")
	g_model_index = precache_model(modelurl)

}
public berubah_Rx(id)
{
	
	effect_hensin(id)
	if (task_exists(id+502134)) remove_task(id+502135)
	set_task(0.65, "RiderChange", id+502135)
	if (task_exists(id+503124)) remove_task(id+503125)
	set_task(get_pcvar_float(kick_cvar[7]), "RiderOff", id+503125)
	
}

public effect_hensin(id)
{
	static Float:MyOrigin[3]
	pev(id, pev_origin, MyOrigin)
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, MyOrigin, 0)
	write_byte(TE_SPRITE)
	engfunc(EngFunc_WriteCoord, MyOrigin[0])
	engfunc(EngFunc_WriteCoord, MyOrigin[1])
	engfunc(EngFunc_WriteCoord, MyOrigin[2] + 20.0)
	write_short(g_spr_hensin)
	write_byte(10)
	write_byte(240)
	message_end()
	PlayEmitSound(id, "rider/teleport_skill1.wav")
	
}

public RiderChange(taskid)
{
	new id = (taskid - 502135)
	set_user_model(id, "rx")
	g_rider[id] = 1
	client_print(id,print_chat,"Plugin %s By:%s ",PLUGIN,AUTHOR)
	if (task_exists(taskid)) remove_task(taskid)
}
public RiderOff(taskid)
{
	new id = (taskid - 503125)
	effect_hensin(id)
	client_print(id,print_chat,"Plugin %s By:%s ",PLUGIN,AUTHOR)
	g_rider[id] = 0
	if (task_exists(taskid)) remove_task(taskid)
}

public fw_CmdStart(id, UCHandle, Seed)
{
	if (!is_user_alive(id)) 
		return
	static CurButton, OldButton;
	CurButton = get_uc(UCHandle, UC_Buttons)
	OldButton = pev(id, pev_oldbuttons)
	
	if((CurButton & IN_USE) && !(OldButton & IN_USE))
	{
		if(!g_rider[id]) return
		if((pev(id, pev_flags) & FL_DUCKING) || pev(id, pev_bInDuck))
			return
			
		cmd_kick(id)
			
		
	}
}
PlayEmitSound(id, const sound[])
{
	emit_sound(id, CHAN_VOICE, sound, 1.0, ATTN_NORM, 0, PITCH_NORM)
}
public cmd_kick(id)
{
	if (!is_user_alive(id)) 
		return
	if(get_pcvar_num(kick_cvar[6]))
	{
		if(!g_fly[id])
		{
			pev(id, pev_viewmodel2, g_OldModel[id], 63)
			static Float:Origin1[3], Float:Origin2[3]
			pev(id, pev_origin, Origin1)
			set_pev(id, pev_viewmodel2, v_kick_m)
			Set_WeaponAnim(id, 0)
			set_pdata_float(id, 83, 0.5, 5)
			get_position(id, 0.0, 0.0, 200.0, Origin2)
			static Float:Velocity[3]; Get_SpeedVector(Origin1, Origin2, get_pcvar_float(kick_cvar[0]), Velocity)
			set_pev(id, pev_velocity, Velocity)
			g_fly[id]=1
			g_action[id] = 1
			if (task_exists(id+502134)) remove_task(id+502134)
			set_task(0.65, "RiderKick", id+502134)
		
		}
	}
	else
	{
		if(g_fly[id]==1)
		{
			if (!g_wait[id])
			{
				
				static Float:Origin1[3], Float:Origin2[3]
				pev(id, pev_origin, Origin1)
				set_pdata_float(id, 83, 0.5, 5)
				get_position(id, 650.0, 0.0, -650.0, Origin2)
				Set_WeaponAnim(id, 1)
				static Float:Velocity[3]; Get_SpeedVector(Origin1, Origin2, get_pcvar_float(kick_cvar[1]), Velocity)
				set_pev(id, pev_velocity, Velocity)
				g_wait[id] = 1
				if (task_exists(id+502134)) remove_task(id+502134)
				set_task(get_pcvar_float(kick_cvar[5]), "RemoveWait", id+502134)
				g_fly[id]=0
				Check_KickKnockback(id)
			}
		}
		if(!g_fly[id])
		{
			if (!g_wait[id])
			{
				pev(id, pev_viewmodel2, g_OldModel[id], 63)
				static Float:Origin1[3], Float:Origin2[3]
				pev(id, pev_origin, Origin1)
				set_pev(id, pev_viewmodel2, v_kick_m)
				
				Set_WeaponAnim(id, 0)
				set_pdata_float(id, 83, 0.5, 5)
				get_position(id, 0.0, 0.0, 200.0, Origin2)
				static Float:Velocity[3]; Get_SpeedVector(Origin1, Origin2, get_pcvar_float(kick_cvar[0]), Velocity)
				set_pev(id, pev_velocity, Velocity)
				g_fly[id]=1
				g_action[id] = 1
				
			}
		}
	}
	
}
public Check_KickKnockback(id)
{
	static Float:Origin[3], Float:MyOrigin[3], Float:Speed[3]
	
	pev(id, pev_origin, MyOrigin)
	
	for(new i = 0; i < get_maxplayers(); i++)
	{
		if(!is_user_alive(i)) continue
		if(id == i) continue
		pev(i, pev_origin, Origin)
		if(!is_in_viewcone(id, Origin, 1))
			continue
		if(entity_range(id, i) > get_pcvar_float(kick_cvar[2]))
			continue
		do_attack(id, i, 0, get_pcvar_float(kick_cvar[3]))
		Origin[2] += 36.0
		Get_SpeedVector(MyOrigin, Origin, get_pcvar_float(kick_cvar[4]), Speed)
		set_pev(i, pev_velocity, Speed)
		message_begin(MSG_BROADCAST ,SVC_TEMPENTITY)
		write_byte(TE_EXPLOSION)
		engfunc(EngFunc_WriteCoord, Origin[0])
		engfunc(EngFunc_WriteCoord, Origin[1])
		engfunc(EngFunc_WriteCoord, Origin[2])
		write_short(g_spr_exp)	// sprite index
		write_byte(30)	// scale in 0.1's
		write_byte(15)	// framerate
		write_byte(0)	// flags
		message_end()
	
	}
	if (task_exists(id+503124)) remove_task(id+503124)
	set_task(0.75, "ResetKick", id+503124)
	
}
public RiderKick(taskid)
{
	new id = (taskid - 502134)
	static Float:Origin1[3], Float:Origin2[3]
	pev(id, pev_origin, Origin1)
	set_pdata_float(id, 83, 0.5, 5)
	get_position(id, 650.0, 0.0, -650.0, Origin2)
	Set_WeaponAnim(id, 1)
	static Float:Velocity[3]; Get_SpeedVector(Origin1, Origin2, get_pcvar_float(kick_cvar[1]), Velocity)
	set_pev(id, pev_velocity, Velocity)
	g_fly[id]=0
	g_wait[id] = 1
	if (task_exists(id+502134)) remove_task(id+502134)
	set_task(get_pcvar_float(kick_cvar[5]), "RemoveWait", id+502134)
	
	
	Check_KickKnockback(id)
}
public RemoveWait(taskid)
{
	new id = (taskid - 502134)
	//client_printc(id, "!t[China]!n Skill Heal Telah Siap [5]")
	g_wait[id] = 0
	if (task_exists(taskid)) remove_task(taskid)
}
public ResetKick(taskid)
{
	new id = (taskid - 503124)
	set_pev(id,pev_viewmodel2,g_OldModel[id])
	g_action[id] = 0
	if (task_exists(taskid)) remove_task(taskid)
}
stock Set_WeaponAnim(id, anim)
{
	set_pev(id, pev_weaponanim, anim)
	
	message_begin(MSG_ONE_UNRELIABLE, SVC_WEAPONANIM, _, id)
	write_byte(anim)
	write_byte(0)
	message_end()	
}
stock Get_SpeedVector(const Float:origin1[3],const Float:origin2[3],Float:speed, Float:new_velocity[3])
{
	new_velocity[0] = origin2[0] - origin1[0]
	new_velocity[1] = origin2[1] - origin1[1]
	new_velocity[2] = origin2[2] - origin1[2]
	new Float:num = floatsqroot(speed*speed / (new_velocity[0]*new_velocity[0] + new_velocity[1]*new_velocity[1] + new_velocity[2]*new_velocity[2]))
	new_velocity[0] *= (num * 2.0)
	new_velocity[1] *= (num * 2.0)
	new_velocity[2] *= (num / 2.0)
}  

stock get_position(id,Float:forw, Float:right, Float:up, Float:vStart[])
{
	static Float:vOrigin[3], Float:vAngle[3], Float:vForward[3], Float:vRight[3], Float:vUp[3]
	
	pev(id, pev_origin, vOrigin)
	pev(id, pev_view_ofs, vUp) //for player
	xs_vec_add(vOrigin, vUp, vOrigin)
	pev(id, pev_v_angle, vAngle) // if normal entity ,use pev_angles
	
	vAngle[0] = 0.0
	
	angle_vector(vAngle,ANGLEVECTOR_FORWARD, vForward) //or use EngFunc_AngleVectors
	angle_vector(vAngle,ANGLEVECTOR_RIGHT, vRight)
	angle_vector(vAngle,ANGLEVECTOR_UP, vUp)
	
	vStart[0] = vOrigin[0] + vForward[0] * forw + vRight[0] * right + vUp[0] * up
	vStart[1] = vOrigin[1] + vForward[1] * forw + vRight[1] * right + vUp[1] * up
	vStart[2] = vOrigin[2] + vForward[2] * forw + vRight[2] * right + vUp[2] * up
}

do_attack(Attacker, Victim, Inflictor, Float:fDamage)
{
	fake_player_trace_attack(Attacker, Victim, fDamage)
	fake_take_damage(Attacker, Victim, fDamage, Inflictor)
	
}

fake_player_trace_attack(iAttacker, iVictim, &Float:fDamage)
{
	// get fDirection
	new Float:fAngles[3], Float:fDirection[3]
	pev(iAttacker, pev_angles, fAngles)
	angle_vector(fAngles, ANGLEVECTOR_FORWARD, fDirection)
	
	// get fStart
	new Float:fStart[3], Float:fViewOfs[3]
	pev(iAttacker, pev_origin, fStart)
	pev(iAttacker, pev_view_ofs, fViewOfs)
	xs_vec_add(fViewOfs, fStart, fStart)
	
	// get aimOrigin
	new iAimOrigin[3], Float:fAimOrigin[3]
	get_user_origin(iAttacker, iAimOrigin, 3)
	IVecFVec(iAimOrigin, fAimOrigin)
	
	// TraceLine from fStart to AimOrigin
	new ptr = create_tr2() 
	engfunc(EngFunc_TraceLine, fStart, fAimOrigin, DONT_IGNORE_MONSTERS, iAttacker, ptr)
	new pHit = get_tr2(ptr, TR_pHit)
	new iHitgroup = get_tr2(ptr, TR_iHitgroup)
	new Float:fEndPos[3]
	get_tr2(ptr, TR_vecEndPos, fEndPos)

	// get target & body at aiming
	new iTarget, iBody
	get_user_aiming(iAttacker, iTarget, iBody)
	
	// if aiming find target is iVictim then update iHitgroup
	if (iTarget == iVictim)
	{
		iHitgroup = iBody
	}
	
	// if ptr find target not is iVictim
	else if (pHit != iVictim)
	{
		// get AimOrigin in iVictim
		new Float:fVicOrigin[3], Float:fVicViewOfs[3], Float:fAimInVictim[3]
		pev(iVictim, pev_origin, fVicOrigin)
		pev(iVictim, pev_view_ofs, fVicViewOfs) 
		xs_vec_add(fVicViewOfs, fVicOrigin, fAimInVictim)
		fAimInVictim[2] = fStart[2]
		fAimInVictim[2] += get_distance_f(fStart, fAimInVictim) * floattan( fAngles[0] * 2.0, degrees )
		
		// check aim in size of iVictim
		new iAngleToVictim = get_angle_to_target(iAttacker, fVicOrigin)
		iAngleToVictim = abs(iAngleToVictim)
		new Float:fDis = 2.0 * get_distance_f(fStart, fAimInVictim) * floatsin( float(iAngleToVictim) * 0.5, degrees )
		new Float:fVicSize[3]
		pev(iVictim, pev_size , fVicSize)
		if ( fDis <= fVicSize[0] * 0.5 )
		{
			// TraceLine from fStart to aimOrigin in iVictim
			new ptr2 = create_tr2() 
			engfunc(EngFunc_TraceLine, fStart, fAimInVictim, DONT_IGNORE_MONSTERS, iAttacker, ptr2)
			new pHit2 = get_tr2(ptr2, TR_pHit)
			new iHitgroup2 = get_tr2(ptr2, TR_iHitgroup)
			
			// if ptr2 find target is iVictim
			if ( pHit2 == iVictim && (iHitgroup2 != HIT_HEAD || fDis <= fVicSize[0] * 0.25) )
			{
				pHit = iVictim
				iHitgroup = iHitgroup2
				get_tr2(ptr2, TR_vecEndPos, fEndPos)
			}
			
			free_tr2(ptr2)
		}
		
		// if pHit still not is iVictim then set default HitGroup
		if (pHit != iVictim)
		{
			// set default iHitgroup
			iHitgroup = HIT_GENERIC
			
			new ptr3 = create_tr2() 
			engfunc(EngFunc_TraceLine, fStart, fVicOrigin, DONT_IGNORE_MONSTERS, iAttacker, ptr3)
			get_tr2(ptr3, TR_vecEndPos, fEndPos)
			
			// free ptr3
			free_tr2(ptr3)
		}
	}
	
	// set new Hit & Hitgroup & EndPos
	set_tr2(ptr, TR_pHit, iVictim)
	set_tr2(ptr, TR_iHitgroup, iHitgroup)
	set_tr2(ptr, TR_vecEndPos, fEndPos)
	
	// hitgroup multi fDamage
	new Float:fMultifDamage 
	switch(iHitgroup)
	{
		case HIT_HEAD: fMultifDamage  = 2.0
		case HIT_STOMACH: fMultifDamage  = 1.10
		case HIT_LEFTLEG: fMultifDamage  = 0.75
		case HIT_RIGHTLEG: fMultifDamage  = 0.75
		default: fMultifDamage  = 1.0
	}
	
	fDamage *= 2.0 
	
	// ExecuteHam
	fake_trake_attack(iAttacker, iVictim, fDamage, fDirection, ptr)
	
	// free ptr
	free_tr2(ptr)
}

stock fake_trake_attack(iAttacker, iVictim, Float:fDamage, Float:fDirection[3], iTraceHandle, iDamageBit = (DMG_NEVERGIB | DMG_BULLET))
{
	ExecuteHamB(Ham_TraceAttack, iVictim, iAttacker, fDamage, fDirection, iTraceHandle, iDamageBit)
}

stock fake_take_damage(iAttacker, iVictim, Float:fDamage, iInflictor = 0, iDamageBit = (DMG_NEVERGIB | DMG_BULLET))
{
	iInflictor = (!iInflictor) ? iAttacker : iInflictor
	ExecuteHamB(Ham_TakeDamage, iVictim, iInflictor, iAttacker, fDamage, iDamageBit)
}
stock get_angle_to_target(id, const Float:fTarget[3], Float:TargetSize = 0.0)
{
	new Float:fOrigin[3], iAimOrigin[3], Float:fAimOrigin[3], Float:fV1[3]
	pev(id, pev_origin, fOrigin)
	get_user_origin(id, iAimOrigin, 3) // end position from eyes
	IVecFVec(iAimOrigin, fAimOrigin)
	xs_vec_sub(fAimOrigin, fOrigin, fV1)
	
	new Float:fV2[3]
	xs_vec_sub(fTarget, fOrigin, fV2)
	
	new iResult = get_angle_between_vectors(fV1, fV2)
	
	if (TargetSize > 0.0)
	{
		new Float:fTan = TargetSize / get_distance_f(fOrigin, fTarget)
		new fAngleToTargetSize = floatround( floatatan(fTan, degrees) )
		iResult -= (iResult > 0) ? fAngleToTargetSize : -fAngleToTargetSize
	}
	
	return iResult
}

stock get_angle_between_vectors(const Float:fV1[3], const Float:fV2[3])
{
	new Float:fA1[3], Float:fA2[3]
	engfunc(EngFunc_VecToAngles, fV1, fA1)
	engfunc(EngFunc_VecToAngles, fV2, fA2)
	
	new iResult = floatround(fA1[1] - fA2[1])
	iResult = iResult % 360
	iResult = (iResult > 180) ? (iResult - 360) : iResult
	
	return iResult
}
set_user_model(id, model[])
{
	if (!is_user_connected(id)) return;
	new model_url[64]
	format(model_url, charsmax(model_url), g_dir_model, model, model)
	cs_set_user_model(id, model)
	set_pev(id, pev_model, model_url)
	set_user_model_index(id, g_model_index)
}
set_user_model_index(id, model_index)
{
	fm_cs_set_user_model_index(id, model_index)
}

stock fm_cs_set_user_model_index(id, value)
{
	if (!value) return;
	set_pdata_int(id, OFFSET_MODELINDEX, value, OFFSET_LINUX)
}

